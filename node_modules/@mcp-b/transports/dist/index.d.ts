import { JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js';
import { Transport, TransportSendOptions } from '@modelcontextprotocol/sdk/shared/transport.js';

/**
 * Unique identifier for an event in the event store
 */
type EventId = string;
/**
 * Unique identifier for a stream of events
 */
type StreamId = string;
/**
 * Options for connecting to an MCP server
 */
interface MCPConnectOptions {
    /**
     * The event ID to resume from if reconnecting
     */
    resumeFrom?: EventId;
}
/**
 * Information about the MCP server
 */
interface MCPServerInfo {
    /**
     * Unique identifier for this server instance
     */
    instanceId: string;
    /**
     * Whether the server maintains session state
     */
    stateful: boolean;
    /**
     * Whether the server has event storage enabled
     */
    hasEventStore: boolean;
}
/**
 * Event storage interface for accessing stored events
 */
interface MCPEventStore {
    /**
     * Get stored events, optionally filtered by client and/or after a specific event
     * @param clientId - Optional client ID to filter events
     * @param afterEventId - Optional event ID to get events after
     * @param limit - Maximum number of events to return (default: 100)
     */
    getEvents(clientId?: string, afterEventId?: EventId, limit?: number): StoredEvent[];
    /**
     * Get the ID of the last event, optionally for a specific client
     * @param clientId - Optional client ID to filter by
     */
    getLastEventId(clientId?: string): EventId | null;
    /**
     * Clear stored events, optionally for a specific client
     * @param clientId - Optional client ID to clear events for
     */
    clearEvents(clientId?: string): void;
}
/**
 * The MCP interface exposed on window for browser environments
 */
interface MCPBrowserInterface {
    /**
     * Connect a client to the MCP server
     * @param clientId - Unique identifier for the client
     * @param options - Optional connection options
     * @returns MessagePort for communication or null if connection fails
     */
    connect(clientId: string, options?: MCPConnectOptions): MessagePort | null;
    /**
     * Disconnect a client from the MCP server
     * @param clientId - The client ID to disconnect
     */
    disconnect(clientId: string): void;
    /**
     * Terminate a client's session and clean up all associated resources
     * @param clientId - The client ID to terminate
     */
    terminateSession?(clientId: string): void;
    /**
     * Check if the MCP server is available and running
     */
    isServerAvailable(): boolean;
    /**
     * Get information about the MCP server
     */
    getServerInfo(): MCPServerInfo;
    /**
     * Event storage access (only available in stateful mode with event store)
     */
    events?: MCPEventStore;
}
/**
 * Extended Window interface with MCP support
 */
interface MCPWindow extends Window {
    mcp?: MCPBrowserInterface;
}
/**
 * Message types for internal MCP communication
 */
interface MCPServerInfoMessage {
    type: 'mcp-server-info';
    serverInstanceId: string;
    serverSessionId?: string;
    hasEventStore: boolean;
    streamId: StreamId;
}
interface MCPEventMessage {
    type: 'mcp-event';
    eventId: EventId;
    message: JSONRPCMessage;
}
interface MCPReplayEventMessage {
    type: 'mcp-replay-event';
    eventId: EventId;
    message: JSONRPCMessage;
}
/**
 * Stored event with metadata for event sourcing
 */
interface StoredEvent {
    eventId: EventId;
    streamId: StreamId;
    message: JSONRPCMessage;
    timestamp: number;
    clientId: string;
}
declare enum NativeMessageType {
    START = "start",
    STARTED = "started",
    STOP = "stop",
    STOPPED = "stopped",
    PING = "ping",
    PONG = "pong",
    ERROR = "error",
    LIST_TOOLS = "list_tools",
    CALL_TOOL = "call_tool",
    TOOL_LIST_UPDATED = "tool_list_updated",
    TOOL_LIST_UPDATED_ACK = "tool_list_updated_ack",
    PROCESS_DATA = "process_data",
    SERVER_STARTED = "server_started",
    SERVER_STOPPED = "server_stopped",
    ERROR_FROM_NATIVE_HOST = "error_from_native_host",
    CONNECT_NATIVE = "connectNative",
    PING_NATIVE = "ping_native",
    DISCONNECT_NATIVE = "disconnect_native"
}
/**
 * Chrome Extension Constants
 * Centralized configuration values and magic constants
 */
declare const NATIVE_HOST: {
    readonly NAME: "com.chromemcp.nativehost";
    readonly DEFAULT_PORT: 12306;
};
declare const ERROR_MESSAGES: {
    readonly NATIVE_CONNECTION_FAILED: "Failed to connect to native host";
    readonly NATIVE_DISCONNECTED: "Native connection disconnected";
    readonly SERVER_STATUS_LOAD_FAILED: "Failed to load server status";
    readonly TOOL_EXECUTION_FAILED: "Tool execution failed";
    readonly SERVER_STATUS_SAVE_FAILED: "Failed to save server status";
};
declare const SUCCESS_MESSAGES: {
    readonly TOOL_EXECUTED: "Tool executed successfully";
    readonly CONNECTION_ESTABLISHED: "Connection established";
    readonly SERVER_STARTED: "Server started successfully";
    readonly SERVER_STOPPED: "Server stopped successfully";
};
declare const STORAGE_KEYS: {
    readonly SERVER_STATUS: "serverStatus";
};
declare const BACKGROUND_MESSAGE_TYPES: {
    readonly GET_SERVER_STATUS: "get_server_status";
    readonly REFRESH_SERVER_STATUS: "refresh_server_status";
    readonly SERVER_STATUS_CHANGED: "server_status_changed";
};
declare const HOST_NAME: "com.chromemcp.nativehost";
/**
 * Server status management interface
 */
interface ServerStatus {
    isRunning: boolean;
    port?: number;
    lastUpdated: number;
}

/**
 * Configuration options for ExtensionClientTransport
 */
interface ExtensionClientTransportOptions {
    /**
     * The extension ID to connect to (optional for same-extension connections)
     */
    extensionId?: string;
    /**
     * Port name for the connection
     * Default: 'mcp'
     */
    portName?: string;
    /**
     * Enable automatic reconnection on disconnect
     * Default: true
     */
    autoReconnect?: boolean;
    /**
     * Maximum number of reconnection attempts
     * Default: 10
     */
    maxReconnectAttempts?: number;
    /**
     * Initial reconnection delay in milliseconds
     * Default: 1000
     */
    reconnectDelay?: number;
    /**
     * Maximum reconnection delay in milliseconds
     * Default: 30000
     */
    maxReconnectDelay?: number;
    /**
     * Reconnection backoff multiplier
     * Default: 1.5
     */
    reconnectBackoffMultiplier?: number;
}
/**
 * Client transport for Chrome extensions using Port-based messaging.
 * This transport can be used in content scripts, popup scripts, or sidepanel scripts
 * to connect to a server running in the background service worker.
 *
 * Features automatic reconnection to handle background service worker lifecycle.
 */
declare class ExtensionClientTransport implements Transport {
    private _port?;
    private _extensionId?;
    private _portName;
    private _messageHandler?;
    private _disconnectHandler?;
    private _isReconnecting;
    private _reconnectAttempts;
    private _reconnectTimer?;
    private _currentReconnectDelay;
    private _isStarted;
    private _isClosed;
    private _autoReconnect;
    private _maxReconnectAttempts;
    private _reconnectDelay;
    private _maxReconnectDelay;
    private _reconnectBackoffMultiplier;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage) => void;
    constructor(options?: ExtensionClientTransportOptions);
    /**
     * Starts the transport by connecting to the extension port
     */
    start(): Promise<void>;
    /**
     * Connects to the extension port
     */
    private _connect;
    /**
     * Sends a message to the server
     */
    send(message: JSONRPCMessage, _options?: TransportSendOptions): Promise<void>;
    /**
     * Closes the transport
     */
    close(): Promise<void>;
    /**
     * Cleans up event listeners and references
     */
    private _cleanup;
    /**
     * Schedules a reconnection attempt
     */
    private _scheduleReconnect;
    /**
     * Attempts to reconnect to the extension
     */
    private _attemptReconnect;
}

/**
 * Configuration options for ExtensionServerTransport
 */
type ExtensionServerTransportOptions = {
    /**
     * Enable keep-alive mechanism to prevent service worker shutdown
     * Default: true
     */
    keepAlive?: boolean;
    /**
     * Keep-alive interval in milliseconds
     * Default: 25000 (25 seconds, less than Chrome's 30-second timeout)
     */
    keepAliveInterval?: number;
};
/**
 * Server transport for Chrome extensions using Port-based messaging.
 * This transport handles a single client connection through Chrome's port messaging API.
 * It should be used in the extension's background service worker.
 *
 * Features:
 * - Keep-alive mechanism to prevent service worker shutdown
 * - Graceful connection state management
 */
declare class ExtensionServerTransport implements Transport {
    private _port;
    private _started;
    private _messageHandler?;
    private _disconnectHandler?;
    private _keepAliveTimer?;
    private _options;
    private _connectionInfo;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage) => void;
    constructor(port: chrome.runtime.Port, options?: ExtensionServerTransportOptions);
    /**
     * Starts the transport and begins handling messages
     */
    start(): Promise<void>;
    /**
     * Sends a message to the client
     */
    send(message: JSONRPCMessage, _options?: TransportSendOptions): Promise<void>;
    /**
     * Closes the transport
     */
    close(): Promise<void>;
    /**
     * Cleans up event listeners and references
     */
    private _cleanup;
    /**
     * Starts the keep-alive mechanism
     */
    private _startKeepAlive;
    /**
     * Stops the keep-alive mechanism
     */
    private _stopKeepAlive;
    /**
     * Gets connection information
     */
    getConnectionInfo(): {
        uptime: number;
        isConnected: boolean;
        connectedAt: number;
        lastMessageAt: number;
        messageCount: number;
    };
}

interface TabClientTransportOptions {
    targetOrigin: string;
    channelId?: string;
}
declare class TabClientTransport implements Transport {
    private _started;
    private _targetOrigin;
    private _channelId;
    private _messageHandler?;
    readonly serverReadyPromise: Promise<void>;
    private _serverReadyResolve;
    private _serverReadyReject;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage) => void;
    constructor(options: TabClientTransportOptions);
    start(): Promise<void>;
    private sendCheckReady;
    send(message: JSONRPCMessage): Promise<void>;
    close(): Promise<void>;
}

interface TabServerTransportOptions {
    allowedOrigins: string[];
    channelId?: string;
}
declare class TabServerTransport implements Transport {
    private _started;
    private _allowedOrigins;
    private _channelId;
    private _messageHandler?;
    private _clientOrigin?;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage) => void;
    constructor(options: TabServerTransportOptions);
    start(): Promise<void>;
    send(message: JSONRPCMessage): Promise<void>;
    close(): Promise<void>;
}

/**
 * Configuration options for UserScriptClientTransport
 */
interface UserScriptClientTransportOptions {
    /**
     * The extension ID to connect to (optional for same-extension connections)
     */
    extensionId?: string;
    /**
     * Port name for the connection
     * Default: 'mcp'
     */
    portName?: string;
    /**
     * Enable automatic reconnection on disconnect
     * Default: true
     */
    autoReconnect?: boolean;
    /**
     * Maximum number of reconnection attempts
     * Default: 10
     */
    maxReconnectAttempts?: number;
    /**
     * Initial reconnection delay in milliseconds
     * Default: 1000
     */
    reconnectDelay?: number;
    /**
     * Maximum reconnection delay in milliseconds
     * Default: 30000
     */
    maxReconnectDelay?: number;
    /**
     * Reconnection backoff multiplier
     * Default: 1.5
     */
    reconnectBackoffMultiplier?: number;
}
/**
 * Client transport for Chrome MV3 User Scripts using Port-based messaging.
 * This transport can be used inside a User Script context to connect to the
 * extension's background service worker. On the extension side, connections
 * are received via chrome.runtime.onUserScriptConnect.
 *
 * Features automatic reconnection to handle background service worker lifecycle.
 */
declare class UserScriptClientTransport implements Transport {
    private _port?;
    private _extensionId?;
    private _portName;
    private _messageHandler?;
    private _disconnectHandler?;
    private _isReconnecting;
    private _reconnectAttempts;
    private _reconnectTimer?;
    private _currentReconnectDelay;
    private _isStarted;
    private _isClosed;
    private _autoReconnect;
    private _maxReconnectAttempts;
    private _reconnectDelay;
    private _maxReconnectDelay;
    private _reconnectBackoffMultiplier;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage) => void;
    constructor(options?: UserScriptClientTransportOptions);
    /**
     * Starts the transport by connecting to the extension port
     */
    start(): Promise<void>;
    /**
     * Connects to the extension port
     */
    private _connect;
    /**
     * Sends a message to the server
     */
    send(message: JSONRPCMessage, _options?: TransportSendOptions): Promise<void>;
    /**
     * Closes the transport
     */
    close(): Promise<void>;
    /**
     * Cleans up event listeners and references
     */
    private _cleanup;
    /**
     * Schedules a reconnection attempt
     */
    private _scheduleReconnect;
    /**
     * Attempts to reconnect to the extension
     */
    private _attemptReconnect;
}

/**
 * Configuration options for UserScriptServerTransport
 */
type UserScriptServerTransportOptions = {
    /**
     * Enable keep-alive mechanism to prevent service worker shutdown
     * Default: true
     */
    keepAlive?: boolean;
    /**
     * Keep-alive interval in milliseconds
     * Default: 25000 (25 seconds, less than Chrome's 30-second timeout)
     */
    keepAliveInterval?: number;
};
/**
 * Server transport for Chrome MV3 User Scripts using Port-based messaging.
 * This transport handles a single client connection through Chrome's port
 * messaging API. It should be used in the extension's background service
 * worker. Connections are initiated from User Scripts via chrome.runtime.connect
 * and received here via chrome.runtime.onUserScriptConnect.
 *
 * Features:
 * - Keep-alive mechanism to prevent service worker shutdown
 * - Graceful connection state management
 */
declare class UserScriptServerTransport implements Transport {
    private _port;
    private _started;
    private _messageHandler?;
    private _disconnectHandler?;
    private _keepAliveTimer?;
    private _options;
    private _connectionInfo;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage) => void;
    constructor(port: chrome.runtime.Port, options?: UserScriptServerTransportOptions);
    /**
     * Starts the transport and begins handling messages
     */
    start(): Promise<void>;
    /**
     * Sends a message to the client
     */
    send(message: JSONRPCMessage, _options?: TransportSendOptions): Promise<void>;
    /**
     * Closes the transport
     */
    close(): Promise<void>;
    /**
     * Cleans up event listeners and references
     */
    private _cleanup;
    /**
     * Starts the keep-alive mechanism
     */
    private _startKeepAlive;
    /**
     * Stops the keep-alive mechanism
     */
    private _stopKeepAlive;
    /**
     * Gets connection information
     */
    getConnectionInfo(): {
        uptime: number;
        isConnected: boolean;
        connectedAt: number;
        lastMessageAt: number;
        messageCount: number;
    };
}

export { BACKGROUND_MESSAGE_TYPES, ERROR_MESSAGES, type EventId, ExtensionClientTransport, type ExtensionClientTransportOptions, ExtensionServerTransport, type ExtensionServerTransportOptions, HOST_NAME, type MCPBrowserInterface, type MCPConnectOptions, type MCPEventMessage, type MCPEventStore, type MCPReplayEventMessage, type MCPServerInfo, type MCPServerInfoMessage, type MCPWindow, NATIVE_HOST, NativeMessageType, STORAGE_KEYS, SUCCESS_MESSAGES, type ServerStatus, type StoredEvent, type StreamId, TabClientTransport, type TabClientTransportOptions, TabServerTransport, type TabServerTransportOptions, UserScriptClientTransport, type UserScriptClientTransportOptions, UserScriptServerTransport, type UserScriptServerTransportOptions };
